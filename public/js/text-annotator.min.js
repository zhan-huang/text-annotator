/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var TextAnnotator;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/ext/sbd.js":
/*!**************************!*\
  !*** ./build/ext/sbd.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = getSentences;\n// the sbd lib was modified from https://github.com/Tessmore/sbd\nlet abbreviations = [];\nconst englishAbbreviations = ['al', 'adj', 'assn', 'Ave', 'BSc', 'MSc', 'Cell', 'Ch', 'Co', 'cc', 'Corp', 'Dem', 'Dept', 'ed', 'eg', 'Eq', 'Eqs', 'est', 'est', 'etc', 'Ex', 'ext', 'Fig', 'fig', 'Figs', 'figs', 'i.e', 'ie', 'Inc', 'inc', 'Jan', 'Feb', 'Mar', 'Apr', 'Jun', 'Jul', 'Aug', 'Sep', 'Sept', 'Oct', 'Nov', 'Dec', 'jr', 'mi', 'Miss', 'Mrs', 'Mr', 'Ms', 'Mol', 'mt', 'mts', 'no', 'Nos', 'PhD', 'MD', 'BA', 'MA', 'MM', 'pl', 'pop', 'pp', 'Prof', 'Dr', 'pt', 'Ref', 'Refs', 'Rep', 'repr', 'rev', 'Sec', 'Secs', 'Sgt', 'Col', 'Gen', 'Rep', 'Sen', 'Gov', 'Lt', 'Maj', 'Capt', 'St', 'Sr', 'sr', 'Jr', 'jr', 'Rev', 'Sun', 'Mon', 'Tu', 'Tue', 'Tues', 'Wed', 'Th', 'Thu', 'Thur', 'Thurs', 'Fri', 'Sat', 'trans', 'Univ', 'Viz', 'Vol', 'vs', 'v'];\n\nconst setAbbreviations = abbr => {\n  if (abbr) {\n    abbreviations = abbr;\n  } else {\n    abbreviations = englishAbbreviations;\n  }\n};\n\nconst isCapitalized = str => {\n  return /^[A-Z][a-z].*/.test(str) || isNumber(str);\n};\n\nconst isSentenceStarter = str => {\n  return isCapitalized(str) || /``|\"|'/.test(str.substring(0, 2));\n};\n\nconst isCommonAbbreviation = str => {\n  return ~abbreviations.indexOf(str.replace(/\\W+/g, ''));\n};\n\nconst isTimeAbbreviation = (word, next) => {\n  if (word === 'a.m.' || word === 'p.m.') {\n    const tmp = next.replace(/\\W+/g, '').slice(-3).toLowerCase();\n\n    if (tmp === 'day') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst isDottedAbbreviation = word => {\n  const matches = word.replace(/[()[\\]{}]/g, '').match(/(.\\.)*/);\n  return matches && matches[0].length > 0;\n};\n\nconst isCustomAbbreviation = str => {\n  if (str.length <= 3) {\n    return true;\n  }\n\n  return isCapitalized(str);\n};\n\nconst isNameAbbreviation = (wordCount, words) => {\n  if (words.length > 0) {\n    if (wordCount < 5 && words[0].length < 6 && isCapitalized(words[0])) {\n      return true;\n    }\n\n    const capitalized = words.filter(str => {\n      return /[A-Z]/.test(str.charAt(0));\n    });\n    return capitalized.length >= 3;\n  }\n\n  return false;\n};\n\nconst isNumber = (str, dotPos) => {\n  if (dotPos) {\n    str = str.slice(dotPos - 1, dotPos + 2);\n  }\n\n  return !isNaN(str);\n};\n\nconst isPhoneNr = str => {\n  return str.match(/^(?:(?:\\+?1\\s*(?:[.-]\\s*)?)?(?:\\(\\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\\s*\\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\\s*(?:[.-]\\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\\s*(?:[.-]\\s*)?([0-9]{4})(?:\\s*(?:#|x\\.?|ext\\.?|extension)\\s*(\\d+))?$/);\n};\n\nconst isURL = str => {\n  return str.match(/[-a-zA-Z0-9@:%._+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/);\n};\n\nconst isConcatenated = word => {\n  let i = 0;\n\n  if ((i = word.indexOf('.')) > -1 || (i = word.indexOf('!')) > -1 || (i = word.indexOf('?')) > -1) {\n    const c = word.charAt(i + 1);\n\n    if (c.match(/[a-zA-Z].*/)) {\n      return [word.slice(0, i + 1), word.slice(i + 1)];\n    }\n  }\n\n  return false;\n};\n\nconst isBoundaryChar = word => {\n  return word === '.' || word === '!' || word === '?';\n};\n\nconst sanitizeHtml = text => {\n  if ((typeof text == 'string' || text instanceof String) && typeof document !== 'undefined') {\n    const $div = document.createElement('DIV');\n    $div.innerHTML = text;\n    text = ($div.textContent || '').trim();\n  } else if (typeof text === 'object' && text.textContent) {\n    text = (text.textContent || '').trim();\n  }\n\n  return text;\n};\n\nconst endsWithChar = (word, c) => {\n  if (c.length > 1) {\n    return c.indexOf(word.slice(-1)) > -1;\n  }\n\n  return word.slice(-1) === c;\n};\n\nconst endsWith = (word, end) => {\n  return word.slice(word.length - end.length) === end;\n};\n\nfunction getSentences(text, user_options) {\n  const newline_placeholder = ' @~@ ';\n  const newline_placeholder_t = newline_placeholder.trim();\n  const whiteSpaceCheck = new RegExp('\\\\S', '');\n  const addNewLineBoundaries = new RegExp('\\\\n+|[-#=_+*]{4,}', 'g');\n  const splitIntoWords = new RegExp('\\\\S+|\\\\n', 'g');\n\n  if (!text || typeof text !== 'string' || !text.length) {\n    return [];\n  }\n\n  if (!whiteSpaceCheck.test(text)) {\n    return [];\n  }\n\n  const options = {\n    newline_boundaries: false,\n    html_boundaries: false,\n    html_boundaries_tags: ['p', 'div', 'ul', 'ol'],\n    sanitize: false,\n    allowed_tags: false,\n    preserve_whitespace: false,\n    abbreviations: null\n  };\n\n  if (typeof user_options === 'boolean') {\n    options.newline_boundaries = true;\n  } else {\n    for (let k in user_options) {\n      options[k] = user_options[k];\n    }\n  }\n\n  setAbbreviations(options.abbreviations);\n\n  if (options.newline_boundaries) {\n    text = text.replace(addNewLineBoundaries, newline_placeholder);\n  }\n\n  if (options.html_boundaries) {\n    const html_boundaries_regexp = '(<br\\\\s*\\\\/?>|<\\\\/(' + options.html_boundaries_tags.join('|') + ')>)';\n    const re = new RegExp(html_boundaries_regexp, 'g');\n    text = text.replace(re, '$1' + newline_placeholder);\n  }\n\n  if (options.sanitize || options.allowed_tags) {\n    if (!options.allowed_tags) {\n      options.allowed_tags = [''];\n    }\n\n    text = sanitizeHtml(text, {\n      allowedTags: options.allowed_tags\n    });\n  }\n\n  let words;\n  let tokens;\n\n  if (options.preserve_whitespace) {\n    tokens = text.split(/(<br\\s*\\/?>|\\S+|\\n+)/);\n    words = tokens.filter((token, ii) => {\n      return ii % 2;\n    });\n  } else {\n    words = text.trim().match(splitIntoWords);\n  }\n\n  let wordCount = 0;\n  let index = 0;\n  let temp = [];\n  let sentences = [];\n  let current = [];\n\n  if (!words || !words.length) {\n    return [];\n  }\n\n  let tokenIndexInc = 0;\n\n  for (let i = 0, L = words.length; i < L; i++) {\n    wordCount++;\n    current.push(words[i]);\n\n    if (~words[i].indexOf(',')) {\n      wordCount = 0;\n    }\n\n    if (isBoundaryChar(words[i]) || endsWithChar(words[i], '?!') || words[i] === newline_placeholder_t) {\n      if ((options.newline_boundaries || options.html_boundaries) && words[i] === newline_placeholder_t) {\n        current.pop();\n      }\n\n      sentences.push(current);\n      wordCount = 0;\n      current = [];\n      continue;\n    }\n\n    if (endsWithChar(words[i], '\"') || endsWithChar(words[i], '”')) {\n      words[i] = words[i].slice(0, -1);\n      index = i * 2 + 1;\n    }\n\n    if (endsWithChar(words[i], '.')) {\n      if (i + 1 < L) {\n        if (words[i].length === 2 && isNaN(words[i].charAt(0))) {\n          continue;\n        }\n\n        if (isCommonAbbreviation(words[i])) {\n          continue;\n        }\n\n        if (isSentenceStarter(words[i + 1])) {\n          if (isTimeAbbreviation(words[i], words[i + 1])) {\n            continue;\n          }\n\n          if (isNameAbbreviation(wordCount, words.slice(i, 6))) {\n            continue;\n          }\n\n          if (isNumber(words[i + 1])) {\n            if (isCustomAbbreviation(words[i])) {\n              continue;\n            }\n          }\n        } else {\n          if (endsWith(words[i], '..')) {\n            continue;\n          }\n\n          if (isDottedAbbreviation(words[i])) {\n            continue;\n          }\n\n          if (isNameAbbreviation(wordCount, words.slice(i, 5))) {\n            continue;\n          }\n        }\n      }\n\n      sentences.push(current);\n      current = [];\n      wordCount = 0;\n      continue;\n    }\n\n    if ((index = words[i].indexOf('.')) > -1) {\n      if (isNumber(words[i], index)) {\n        continue;\n      }\n\n      if (isDottedAbbreviation(words[i])) {\n        continue;\n      }\n\n      if (isURL(words[i]) || isPhoneNr(words[i])) {\n        continue;\n      }\n    }\n\n    const match = isConcatenated(words[i]);\n\n    if (match) {\n      temp = match;\n      current.pop();\n      current.push(temp[0]);\n      sentences.push(current);\n\n      if (options.preserve_whitespace) {\n        tokens.splice(i * 2 + 1 + tokenIndexInc, 1, temp[0], '', temp[1]);\n        tokenIndexInc += 2;\n      }\n\n      current = [];\n      wordCount = 0;\n      current.push(temp[1]);\n    }\n  }\n\n  if (current.length) {\n    sentences.push(current);\n  }\n\n  const result = [];\n  let sentence = '';\n  sentences = sentences.filter(function (s) {\n    return s.length > 0;\n  });\n\n  for (let i2 = 0; i2 < sentences.length; i2++) {\n    if (options.preserve_whitespace && !options.newline_boundaries && !options.html_boundaries) {\n      let tokenCount = sentences[i2].length * 2;\n\n      if (i2 === 0) {\n        tokenCount += 1;\n      }\n\n      sentence = tokens.splice(0, tokenCount).join('');\n    } else {\n      sentence = sentences[i2].join(' ');\n    }\n\n    if (sentences[i2].length === 1 && sentences[i2][0].length < 4 && sentences[i2][0].indexOf('.') > -1) {\n      if (sentences[i2 + 1] && sentences[i2 + 1][0].indexOf('.') < 0) {\n        sentence += ' ' + sentences[i2 + 1].join(' ');\n        i2++;\n      }\n    }\n\n    result.push(sentence);\n  }\n\n  return result;\n}\n\n//# sourceURL=webpack://TextAnnotator/./build/ext/sbd.js?");

/***/ }),

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nmodule.exports = __webpack_require__(/*! ./text-annotator.js */ \"./build/text-annotator.js\")[\"default\"];\n\n//# sourceURL=webpack://TextAnnotator/./build/index.js?");

/***/ }),

/***/ "./build/text-annotator.js":
/*!*********************************!*\
  !*** ./build/text-annotator.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _sbd = _interopRequireDefault(__webpack_require__(/*! ./ext/sbd */ \"./build/ext/sbd.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst encode = str => {\n  return str.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}; // div inside span is a bad idea\n\n\nconst blockElements = ['address', 'article', 'aside', 'blockquote', 'canvas', 'dd', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'li', 'main', 'nav', 'noscript', 'ol', 'output', 'p', 'pre', 'section', 'table', 'tfoot', 'ul', 'video'];\n\nclass TextAnnotator {\n  constructor(options = {}) {\n    const content = options.content; // isHTML is used to reduce the memory used: stripedHTML is empty if isHTML is false\n\n    const isHTML = options.isHTML === undefined || options.isHTML; // annotatedContent is introduced in order to avoid passing content in the methods\n\n    this.originalContent = this.annotatedContent = content;\n    this.isHTML = isHTML; // stripedHTML and tagLocations are needed only when the content is HTML\n\n    this.stripedHTML = '';\n    this.tagLocations = []; // sentences are used in sentence-based fuzzy search\n\n    this.sentences = []; // future work: one highlight can have more than one location because of the potential issue in tag insertion\n\n    this.highlights = [];\n\n    if (isHTML) {\n      this.stripAndStoreHTMLTags();\n    }\n  } // the order of directSearch => fuzzy search => eager search is tailored for specific feature, it is now the default way of search but it can be customized via options. More customizations can be done by composing functions\n\n\n  search(str, options = {}) {\n    let prefix = options.prefix || '';\n    let postfix = options.postfix || '';\n    const directSearchOptions = options.directSearchOptions || {};\n    const fuzzySearchOptions = options.fuzzySearchOptions;\n    const eagerSearchOptions = options.eagerSearchOptions; // trim by default\n\n    const trim = options.trim === undefined || options.trim; // used unless overwritten\n\n    const caseSensitive = options.caseSensitive;\n\n    if (trim) {\n      const res = TextAnnotator.trim(prefix, str, postfix);\n      prefix = res.prefix;\n      str = res.str;\n      postfix = res.postfix;\n    }\n\n    let highlightIndex = -1; // direct search will always be performed\n\n    highlightIndex = this.directSearch(prefix, str, postfix, Object.assign({\n      caseSensitive\n    }, directSearchOptions));\n\n    if (highlightIndex !== -1) {\n      return highlightIndex;\n    } // experimental feature\n\n\n    if (fuzzySearchOptions) {\n      highlightIndex = this.fuzzySearch(prefix, str, postfix, Object.assign({\n        caseSensitive\n      }, fuzzySearchOptions));\n\n      if (highlightIndex !== -1) {\n        return highlightIndex;\n      }\n    } // experimental feature\n    // eager search only works in (particular) browsers\n\n\n    if (eagerSearchOptions) {\n      highlightIndex = this.eagerSearch(prefix, str, postfix, Object.assign({\n        caseSensitive\n      }, eagerSearchOptions));\n\n      if (highlightIndex !== -1) {\n        return highlightIndex;\n      }\n    }\n\n    return highlightIndex;\n  } // experimental feature\n  // only support direct search for now\n\n\n  searchAll(str, options = {}) {\n    const highlightIndexes = [];\n\n    const continueSearch = (str, options) => {\n      const highlightIndex = this.search(str, options);\n\n      if (highlightIndex !== -1) {\n        highlightIndexes.push(highlightIndex);\n        options.directSearchOptions = options.directSearchOptions || {};\n        options.directSearchOptions.lastHighlightIndex = highlightIndex;\n        continueSearch(str, options);\n      }\n    };\n\n    continueSearch(str, options);\n    return highlightIndexes;\n  }\n\n  highlight(highlightIndex, options = {}) {\n    const highlightTagName = options.highlightTagName || 'span';\n    const highlightClass = options.highlightClass || 'highlight';\n    const highlightIdPattern = options.highlightIdPattern || 'highlight-';\n    const openTag = TextAnnotator.createOpenTag(highlightTagName, highlightIdPattern, highlightIndex, highlightClass);\n    const loc = this.adjustLoc(highlightTagName, highlightIdPattern, highlightIndex, highlightClass);\n    this.annotatedContent = TextAnnotator.insert(this.annotatedContent, openTag, loc[0]);\n    this.annotatedContent = TextAnnotator.insert(this.annotatedContent, TextAnnotator.createCloseTag(highlightTagName), loc[1] + openTag.length); // it has to be set after adjustLoc so that it will not be checked\n\n    this.highlights[highlightIndex].highlighted = true;\n    return this.annotatedContent;\n  } // experimental feature\n\n\n  highlightAll(highlightIndexes, options = {}) {\n    for (let i = 0; i < highlightIndexes.length; i++) {\n      this.annotatedContent = this.highlight(highlightIndexes[i], options);\n    }\n\n    return this.annotatedContent;\n  }\n\n  searchAndHighlight(str, options = {}) {\n    const highlightIndex = this.search(str, options.searchOptions);\n\n    if (highlightIndex !== -1) {\n      return {\n        highlightIndex,\n        content: this.highlight(highlightIndex, options.highlightOptions)\n      };\n    }\n  }\n\n  unhighlight(highlightIndex, options = {}) {\n    const highlightTagName = options.highlightTagName || 'span';\n    const highlightClass = options.highlightClass || 'highlight';\n    const highlightIdPattern = options.highlightIdPattern || 'highlight-'; // it has to be set before adjustLoc so that it will not be checked\n\n    this.highlights[highlightIndex].highlighted = false; // need to change when one annotation => more than one highlight\n\n    const loc = this.adjustLoc(highlightTagName, highlightIdPattern, highlightIndex, highlightClass);\n    const openTagLength = TextAnnotator.getOpenTagLength(highlightTagName, highlightIdPattern, highlightIndex, highlightClass);\n    const substr1 = this.annotatedContent.substring(loc[0], loc[1] + openTagLength + TextAnnotator.getCloseTagLength(highlightTagName));\n    const substr2 = this.annotatedContent.substring(loc[0] + openTagLength, loc[1] + openTagLength);\n    this.annotatedContent = this.annotatedContent.replace(substr1, substr2);\n    return this.annotatedContent;\n  }\n\n  stripAndStoreHTMLTags() {\n    let tag;\n    this.stripedHTML = this.originalContent;\n    const tagRegEx = /<[^>]+>/;\n    let indexInc = 0;\n\n    while (tag = this.stripedHTML.match(tagRegEx)) {\n      this.stripedHTML = this.stripedHTML.replace(tag, '');\n      const tagLength = tag[0].length; // tagLocations will be used in adjustLoc\n\n      this.tagLocations.push([tag.index, tagLength, indexInc]);\n      indexInc += tagLength;\n    }\n  }\n\n  directSearch(prefix, str, postfix, directSearchOptions = {}) {\n    const caseSensitive = directSearchOptions.caseSensitive; // experimental option; used for specific feature\n\n    const ifEncode = directSearchOptions.encode;\n    const lastHighlightIndex = directSearchOptions.lastHighlightIndex;\n    let strWithFixes = prefix + str + postfix;\n    let text = this.isHTML ? this.stripedHTML : this.originalContent;\n\n    if (!caseSensitive) {\n      strWithFixes = strWithFixes.toLowerCase();\n      text = text.toLowerCase();\n    } // for searchAll\n\n\n    let offset = 0;\n\n    if (lastHighlightIndex !== undefined) {\n      offset = this.highlights[lastHighlightIndex].loc[1] + 1;\n    }\n\n    let highlightIndex = -1;\n    const index = text.indexOf(strWithFixes, offset); // experimental feature: if the text to be searched does not work, try to encode it\n\n    if (ifEncode && index === -1) {\n      const encodedStrWithFixes = encode(strWithFixes);\n      const index = text.indexOf(encodedStrWithFixes, offset);\n\n      if (index !== -1) {\n        const loc = [];\n        loc[0] = index + encode(prefix).length;\n        loc[1] = loc[0] + encode(str).length;\n        highlightIndex = this.highlights.push({\n          loc\n        }) - 1;\n      }\n    } else if (index !== -1) {\n      const loc = [];\n      loc[0] = index + prefix.length;\n      loc[1] = loc[0] + str.length;\n      highlightIndex = this.highlights.push({\n        loc\n      }) - 1;\n    }\n\n    return highlightIndex;\n  }\n\n  eagerSearch(prefix, str, postfix, eagerSearchOptions = {}) {\n    const caseSensitive = eagerSearchOptions.caseSensitive;\n    const containerId = eagerSearchOptions.containerId;\n    const threshold = eagerSearchOptions.threshold || 0.74;\n    const strWithFixes = prefix + str + postfix;\n    let highlightIndex = -1; // IE is not considered\n\n    if (window.find) {\n      document.designMode = 'on'; // step 1: ask the browser to highlight the found\n\n      const sel = window.getSelection();\n      sel.collapse(document.body, 0);\n\n      while (window.find(strWithFixes, caseSensitive)) {\n        document.execCommand('hiliteColor', true, 'rgba(255, 255, 255, 0)');\n        sel.collapseToEnd(); // step 2: locate the found within the container where the annotator is applied\n        // selector may become better\n\n        const found = document.querySelector('#' + containerId + ' [style=\"background-color: rgba(255, 255, 255, 0);\"]');\n\n        if (found) {\n          const foundStr = found.innerHTML.replace(/<[^>]*>/g, '');\n          const result = TextAnnotator.getBestSubstring(foundStr, str, threshold);\n\n          if (result.similarity) {\n            const text = this.isHTML ? this.stripedHTML : this.originalContent;\n            const index = text.indexOf(foundStr);\n\n            if (index !== -1) {\n              highlightIndex = this.highlights.push({\n                loc: [index + result.loc[0], index + result.loc[1]]\n              }) - 1;\n            }\n          }\n\n          break;\n        }\n      } // step 3: remove the highlights created by the browser\n\n\n      document.execCommand('undo');\n      document.designMode = 'off';\n    }\n\n    return highlightIndex;\n  }\n\n  fuzzySearch(prefix, str, postfix, fuzzySearchOptions = {}) {\n    const caseSensitive = fuzzySearchOptions.caseSensitive;\n    const tokenBased = fuzzySearchOptions.tokenBased;\n    let tbThreshold = fuzzySearchOptions.tbThreshold || 0.68; // sentence-based fuzzy search is enabled by default\n\n    const sentenceBased = fuzzySearchOptions.sentenceBased === undefined || fuzzySearchOptions.sentenceBased;\n    let sbThreshold = fuzzySearchOptions.sbThreshold || 0.85;\n    const maxLengthDiff = fuzzySearchOptions.maxLengthDiff || 0.1;\n    const lenRatio = fuzzySearchOptions.lenRatio || 2;\n    const processSentence = fuzzySearchOptions.processSentence;\n    let highlightIndex = -1;\n    const text = this.isHTML ? this.stripedHTML : this.originalContent; // token-based\n\n    if (tokenBased || prefix || postfix) {\n      // step 1: find all indexes of str\n      const strIndexes = [];\n      let i = -1;\n\n      while ((i = text.indexOf(str, i + 1)) !== -1) {\n        strIndexes.push(i);\n      } // step 2: find the index of the most similar \"fragment\" - the str with pre- and post- fixes\n\n\n      let strIndex = -1;\n      const fragment = prefix + str + postfix;\n\n      for (let i = 0; i < strIndexes.length; i++) {\n        const si = strIndexes[i]; // f can be wider\n\n        const f = text.substring(si - prefix.length, si) + str + text.substring(si + str.length, si + str.length + postfix.length);\n        const similarity = TextAnnotator.getSimilarity(f, fragment, caseSensitive);\n\n        if (similarity >= tbThreshold) {\n          tbThreshold = similarity;\n          strIndex = si;\n        }\n      } // step 3: check whether the most similar enough \"fragment\" is found, if yes return its location\n\n\n      if (strIndex !== -1) {\n        highlightIndex = this.highlights.push({\n          loc: [strIndex, strIndex + str.length]\n        }) - 1;\n      }\n    } // sentence-based\n    else if (sentenceBased) {\n      // step 1: sentenize the text if has not done so\n      let sentences = [];\n\n      if (this.sentences.length) {\n        sentences = this.sentences;\n      } else {\n        sentences = this.sentences = TextAnnotator.sentenize(text);\n      } // step 2 (for efficiency only): filter sentences by words of the str\n\n\n      const words = str.split(/\\s/);\n      const filteredSentences = [];\n\n      for (let i = 0; i < sentences.length; i++) {\n        for (let j = 0; j < words.length; j++) {\n          if (sentences[i].raw.includes(words[j])) {\n            filteredSentences.push(sentences[i]);\n            break;\n          }\n        }\n      } //step 3 (optional)\n\n\n      if (processSentence) {\n        let index = 0; // for each sentence\n\n        for (let i = 0; i < filteredSentences.length; i++) {\n          const fs = filteredSentences[i];\n          let raw = fs.raw; // loc without tags\n\n          const loc = [fs.index, fs.index + raw.length];\n          let locInc = 0; // add loc of all tags before the one being checked so as to derive the actual loc\n\n          const tagLocations = this.tagLocations; // for each loc of tag whose loc is larger than the last sentence\n\n          for (let j = index; j < tagLocations.length; j++) {\n            const tagLoc = tagLocations[j];\n\n            if (tagLoc[0] >= loc[0] && tagLoc[0] <= loc[1]) {\n              const tag = this.originalContent.substring(tagLoc[0] + tagLoc[2], tagLoc[0] + tagLoc[2] + tagLoc[1]);\n              const insertIndex = tagLoc[0] + locInc - loc[0];\n              raw = raw.slice(0, insertIndex) + tag + raw.slice(insertIndex);\n              locInc += tagLoc[1];\n            } else if (tagLoc[0] > loc[1]) {\n              index = j; // not sure this part\n\n              break;\n            }\n          }\n\n          raw = processSentence(raw);\n          raw = raw.replace(/(<([^>]+)>)/gi, '');\n          const copy = fs.raw; // update the sentence if it got reduced\n\n          if (copy !== raw) {\n            fs.raw = raw;\n            fs.index = fs.index + copy.indexOf(raw);\n          }\n        }\n      } // step 4: find the most possible sentence\n\n\n      let mostPossibleSentence = null;\n\n      for (let i = 0; i < filteredSentences.length; i++) {\n        const sentence = filteredSentences[i];\n        const similarity = TextAnnotator.getSimilarity(sentence.raw, str, caseSensitive);\n\n        if (similarity >= sbThreshold) {\n          sbThreshold = similarity;\n          mostPossibleSentence = sentence;\n        } else if (i !== filteredSentences.length - 1) {\n          // combine two sentences to reduce the inaccuracy of sentenizing text\n          const newSentenceRaw = sentence.raw + filteredSentences[i + 1].raw;\n          const lengthDiff = Math.abs(newSentenceRaw.length - str.length) / str.length;\n\n          if (lengthDiff <= maxLengthDiff) {\n            const newSimilarity = TextAnnotator.getSimilarity(newSentenceRaw, str, caseSensitive);\n\n            if (newSimilarity >= sbThreshold) {\n              sbThreshold = newSimilarity;\n              mostPossibleSentence = {\n                raw: newSentenceRaw,\n                index: sentence.index\n              };\n            }\n          }\n        }\n      } // step 5:  if the most possible sentence is found, derive and return the location of the most similar str from it\n\n\n      if (mostPossibleSentence) {\n        const result = TextAnnotator.getBestSubstring(mostPossibleSentence.raw, str, sbThreshold, lenRatio, caseSensitive, true);\n\n        if (result.loc) {\n          let index = mostPossibleSentence.index;\n          highlightIndex = this.highlights.push({\n            loc: [index + result.loc[0], index + result.loc[1]]\n          }) - 1;\n        }\n      }\n    }\n\n    return highlightIndex;\n  } // future work: further improvement when one annotation binds with more than one highlight\n  // includeRequiredTag used in = condition only\n\n\n  includeRequiredTag(i, highlightLoc, tag) {\n    const isCloseTag = tag.startsWith('</');\n    const tagName = isCloseTag ? tag.split('</')[1].split('>')[0] : tag.split(' ')[0].split('<')[1].split('>')[0];\n    let included = false;\n    let requiredTagNumber = 1;\n    let requiredTagCount = 0; // if both the start tag and the end tag are at the borders, place the tags outside the borders\n    // if the close tag is at the border, check backwards until the start of the highlight\n\n    if (isCloseTag) {\n      for (let i2 = i - 1; i2 >= 0; i2--) {\n        const tagLoc2 = this.tagLocations[i2];\n\n        if (highlightLoc[0] > tagLoc2[0]) {\n          break;\n        } else {\n          const tag2 = this.originalContent.substring(tagLoc2[0] + tagLoc2[2], tagLoc2[0] + tagLoc2[2] + tagLoc2[1]);\n\n          if (tag2.startsWith('</' + tagName)) {\n            requiredTagNumber++;\n          } else if (tag2.startsWith('<' + tagName)) {\n            requiredTagCount++;\n          }\n\n          if (requiredTagNumber === requiredTagCount) {\n            included = true;\n            break;\n          }\n        }\n      }\n    } // if the start tag is at the border, check forwards until the end of the highlight\n    else {\n      for (let i2 = i + 1; i2 < this.tagLocations.length; i2++) {\n        const tagLoc2 = this.tagLocations[i2];\n\n        if (highlightLoc[1] < tagLoc2[0]) {\n          break;\n        } else {\n          const tag2 = this.originalContent.substring(tagLoc2[0] + tagLoc2[2], tagLoc2[0] + tagLoc2[2] + tagLoc2[1]);\n\n          if (tag2.startsWith('<' + tagName)) {\n            requiredTagNumber++;\n          } else if (tag2.startsWith('</' + tagName)) {\n            requiredTagCount++;\n          }\n\n          if (requiredTagNumber === requiredTagCount) {\n            included = true;\n            break;\n          }\n        }\n      }\n    }\n\n    return included;\n  }\n\n  adjustLoc(highlightTagName = 'span', highlightIdPattern, highlightIndex, highlightClass) {\n    const highlightLoc = this.highlights[highlightIndex].loc;\n    const locInc = [0, 0]; // step 1: check locations of tags\n\n    const length = this.tagLocations.length;\n\n    for (let i = 0; i < length; i++) {\n      const tagLoc = this.tagLocations[i]; // start end tag\n\n      if (highlightLoc[1] < tagLoc[0]) {\n        break;\n      } // start end&tag\n      else if (highlightLoc[1] === tagLoc[0]) {\n        const tag = this.originalContent.substring(tagLoc[0] + tagLoc[2], tagLoc[0] + tagLoc[2] + tagLoc[1]); // if end tag, not block element and include the required close tag, add right to the tag\n\n        if (!tag.endsWith('/>') && tag.startsWith('</') && !blockElements.includes(tag.split('</')[1].split('>')[0]) && this.includeRequiredTag(i, highlightLoc, tag)) {\n          locInc[1] += tagLoc[1];\n        }\n      } // start tag end\n      else if (highlightLoc[1] > tagLoc[0]) {\n        locInc[1] += tagLoc[1]; // start&tag end\n\n        if (highlightLoc[0] === tagLoc[0]) {\n          const tag = this.originalContent.substring(tagLoc[0] + tagLoc[2], tagLoc[0] + tagLoc[2] + tagLoc[1]); // if self close tag or end tag or block element or not include the required close tag, add right to the tag\n\n          if (tag.startsWith('</') || tag.endsWith('/>') || blockElements.includes(tag.split(' ')[0].split('<')[1].split('>')[0]) || !this.includeRequiredTag(i, highlightLoc, tag)) {\n            locInc[0] += tagLoc[1];\n          }\n        } // tag start end\n        else if (highlightLoc[0] > tagLoc[0]) {\n          locInc[0] += tagLoc[1];\n        }\n      }\n    } // step 2: check locations of other highlights\n    // all span (no blocks)\n    // stored in a different array than tags\n    // can intersect\n\n\n    for (let i = 0; i < this.highlights.length; i++) {\n      const highlight = this.highlights[i]; // only check the highlighted\n\n      if (highlight.highlighted) {\n        const openTagLength = TextAnnotator.getOpenTagLength(highlightTagName, highlightIdPattern, i, highlightClass);\n        const closeTagLength = TextAnnotator.getCloseTagLength(highlightTagName);\n        const loc = highlight.loc;\n\n        if (highlightLoc[0] >= loc[1]) {\n          locInc[0] += openTagLength + closeTagLength;\n          locInc[1] += openTagLength + closeTagLength;\n        } // syntactical correct but semantical incorrect\n        else if (highlightLoc[0] < loc[1] && highlightLoc[0] > loc[0] && highlightLoc[1] > loc[1]) {\n          locInc[0] += openTagLength;\n          locInc[1] += openTagLength + closeTagLength;\n        } else if (highlightLoc[0] <= loc[0] && highlightLoc[1] >= loc[1]) {\n          locInc[1] += openTagLength + closeTagLength;\n        } // syntactical correct but semantical incorrect\n        else if (highlightLoc[0] < loc[0] && highlightLoc[1] > loc[0] && highlightLoc[1] < loc[1]) {\n          locInc[1] += openTagLength;\n        } else if (highlightLoc[0] >= loc[0] && highlightLoc[1] <= loc[1]) {\n          locInc[0] += openTagLength;\n          locInc[1] += openTagLength;\n        }\n      }\n    }\n\n    return [highlightLoc[0] + locInc[0], highlightLoc[1] + locInc[1]];\n  }\n\n  static createOpenTag(highlightTagName = 'span', highlightIdPattern, highlightIndex, highlightClass) {\n    return `<${highlightTagName} id=\"${highlightIdPattern + highlightIndex}\" class=\"${highlightClass}\">`;\n  }\n\n  static createCloseTag(highlightTagName = 'span') {\n    return `</${highlightTagName}>`;\n  }\n\n  static getOpenTagLength(highlightTagName = 'span', highlightIdPattern, highlightIndex, highlightClass) {\n    return TextAnnotator.createOpenTag(highlightTagName, highlightIdPattern, highlightIndex, highlightClass).length;\n  }\n\n  static getCloseTagLength(highlightTagName = 'span') {\n    return TextAnnotator.createCloseTag(highlightTagName).length;\n  }\n\n  static trim(prefix, str, postfix) {\n    prefix = prefix.replace(/^\\s+/, '');\n    postfix = postfix.replace(/\\s+$/, '');\n\n    if (!prefix) {\n      str = str.replace(/^\\s+/, '');\n    }\n\n    if (!postfix) {\n      str = str.replace(/\\s+$/, '');\n    }\n\n    return {\n      prefix,\n      str,\n      postfix\n    };\n  }\n\n  static insert(str1, str2, index) {\n    return str1.slice(0, index) + str2 + str1.slice(index);\n  }\n\n  static sentenize(text) {\n    const options = {\n      newline_boundaries: false,\n      html_boundaries: false,\n      sanitize: false,\n      allowed_tags: false,\n      preserve_whitespace: true,\n      abbreviations: null\n    };\n    return (0, _sbd.default)(text, options).map(raw => {\n      // future work: can tokenizer return location directly\n      const index = text.indexOf(raw);\n      return {\n        raw,\n        index\n      };\n    });\n  }\n\n  static getBestSubstring(str, substr, threshold, lenRatio, caseSensitive, skipFirstRun) {\n    let result = {};\n    let similarity = skipFirstRun ? threshold : TextAnnotator.getSimilarity(str, substr, caseSensitive);\n\n    if (similarity >= threshold) {\n      // step 1: derive best substr\n      // future work: /s may be better\n      const words = str.split(' ');\n\n      while (words.length) {\n        const firstWord = words.shift();\n        const newStr = words.join(' ');\n        let newSimilarity = TextAnnotator.getSimilarity(newStr, substr, caseSensitive);\n\n        if (newSimilarity < similarity) {\n          words.unshift(firstWord);\n          const lastWord = words.pop();\n          newSimilarity = TextAnnotator.getSimilarity(words.join(' '), substr, caseSensitive);\n\n          if (newSimilarity < similarity) {\n            words.push(lastWord);\n            break;\n          } else {\n            similarity = newSimilarity;\n          }\n        } else {\n          similarity = newSimilarity;\n        }\n      }\n\n      const bestSubstr = words.join(' '); // step 2: return the best substr and its loc if found and if it meets the threshold and the length ratio\n\n      if (!lenRatio || bestSubstr.length / substr.length <= lenRatio) {\n        const loc = [];\n        loc[0] = str.indexOf(bestSubstr);\n        loc[1] = loc[0] + bestSubstr.length;\n        result = {\n          similarity,\n          loc\n        };\n      }\n    }\n\n    return result;\n  }\n\n  static getSimilarity(str1, str2, caseSensitive) {\n    if (!caseSensitive) {\n      str1 = str1.toLowerCase();\n      str2 = str2.toLowerCase();\n    }\n\n    if (str1 === str2) return 1; // set str2 to denominator\n\n    return TextAnnotator.lcsLength(str1, str2) / str2.length;\n  } // copy from the code in https://www.npmjs.com/package/longest-common-subsequence\n\n\n  static lcsLength(firstSequence, secondSequence, caseSensitive) {\n    function createArray(dimension) {\n      const array = [];\n\n      for (let i = 0; i < dimension; i++) {\n        array[i] = [];\n      }\n\n      return array;\n    }\n\n    const firstString = caseSensitive ? firstSequence : firstSequence.toLowerCase();\n    const secondString = caseSensitive ? secondSequence : secondSequence.toLowerCase();\n\n    if (firstString === secondString) {\n      return firstString.length;\n    }\n\n    if ((firstString || secondString) === '') {\n      return ''.length;\n    }\n\n    const firstStringLength = firstString.length;\n    const secondStringLength = secondString.length;\n    const lcsMatrix = createArray(secondStringLength + 1);\n    let i;\n    let j;\n\n    for (i = 0; i <= firstStringLength; i++) {\n      lcsMatrix[0][i] = 0;\n    }\n\n    for (i = 0; i <= secondStringLength; i++) {\n      lcsMatrix[i][0] = 0;\n    }\n\n    for (i = 1; i <= secondStringLength; i++) {\n      for (j = 1; j <= firstStringLength; j++) {\n        if (firstString[j - 1] === secondString[i - 1]) {\n          lcsMatrix[i][j] = lcsMatrix[i - 1][j - 1] + 1;\n        } else {\n          lcsMatrix[i][j] = Math.max(lcsMatrix[i - 1][j], lcsMatrix[i][j - 1]);\n        }\n      }\n    }\n\n    let lcs = '';\n    i = secondStringLength;\n    j = firstStringLength;\n\n    while (i > 0 && j > 0) {\n      if (firstString[j - 1] === secondString[i - 1]) {\n        lcs = firstString[j - 1] + lcs;\n        i--;\n        j--;\n      } else if (Math.max(lcsMatrix[i - 1][j], lcsMatrix[i][j - 1]) === lcsMatrix[i - 1][j]) {\n        i--;\n      } else {\n        j--;\n      }\n    }\n\n    return lcs.length;\n  }\n\n}\n\nvar _default = TextAnnotator;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://TextAnnotator/./build/text-annotator.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/index.js");
/******/ 	TextAnnotator = __webpack_exports__;
/******/ 	
/******/ })()
;